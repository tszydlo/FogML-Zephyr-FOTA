/**
 * Generated by anjay_codegen.py on 2021-08-26 15:57:19
 *
 * LwM2M Object: Anomaly Analyzer
 * ID: 33653, URN: urn:oma:lwm2m:ext:33653, Optional, Single
 *
 * This object is used to report the sensor data that are significantly
 * different from the data in the training dataset.
 */
#include <assert.h>
#include <stdbool.h>

#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_memory.h>

#include <zephyr.h>

#include "../processing.h"
#include "../utils.h"
#include "objects.h"

/**
 * Maximum Anomaly Score: R, Single, Mandatory
 * type: float, range: N/A, unit: N/A
 * Maximum value of the anomaly observed in the sensor data in a time
 * window.
 */
#define RID_MAXIMUM_ANOMALY_SCORE 2000

/**
 * RAW Data: R, Single, Optional
 * type: opaque, range: N/A, unit: N/A
 * The senor data for which maximum anomaly has been detected in the time
 * window. The data is serialized using FlatBuffers.
 */
#define RID_RAW_DATA 2001

/**
 * Reset: E, Single, Mandatory
 * type: N/A, range: N/A, unit: N/A
 * Action to reset stored data.
 */
#define RID_RESET 2002

typedef struct anomaly_analyzer_object_struct {
    const anjay_dm_object_def_t *def;

    struct k_mutex instance_state_mtx;

    int window_size;
    float anomaly_score;
    float sensor_data[];
} anomaly_analyzer_object_t;

static inline anomaly_analyzer_object_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, anomaly_analyzer_object_t, def);
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

    anjay_dm_emit_res(ctx, RID_MAXIMUM_ANOMALY_SCORE,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_RAW_DATA,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_RESET,
                      ANJAY_DM_RES_E, ANJAY_DM_RES_PRESENT);
    return 0;
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;

    anomaly_analyzer_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {
    case RID_MAXIMUM_ANOMALY_SCORE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_float(ctx, obj->anomaly_score);

    case RID_RAW_DATA:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_bytes(ctx, obj->sensor_data, obj->window_size * sizeof(float));

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_execute(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid,
                            anjay_rid_t rid,
                            anjay_execute_ctx_t *arg_ctx) {
    (void) arg_ctx;

    anomaly_analyzer_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    assert(iid == 0);

    switch (rid) {
    case RID_RESET:
        obj->anomaly_score = -1.0;
        return 0;

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = 33653,
    .handlers = {
        .list_instances = anjay_dm_list_instances_SINGLE,

        .list_resources = list_resources,
        .resource_read = resource_read,
        .resource_execute = resource_execute,

        .transaction_begin = anjay_dm_transaction_NOOP,
        .transaction_validate = anjay_dm_transaction_NOOP,
        .transaction_commit = anjay_dm_transaction_NOOP,
        .transaction_rollback = anjay_dm_transaction_NOOP
    }
};

const anjay_dm_object_def_t **anomaly_analyzer_object_create(int window_size) {
    anomaly_analyzer_object_t *obj = (anomaly_analyzer_object_t *)avs_calloc(1, sizeof(anomaly_analyzer_object_t) + window_size * sizeof(float));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    obj->anomaly_score = -1;

    obj->window_size = window_size;

    k_mutex_init(&obj->instance_state_mtx);

    return &obj->def;
}

void anomaly_analyzer_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        anomaly_analyzer_object_t *obj = get_obj(def);

        avs_free(obj);
    }
}

void anomaly_analyzer_object_update_sensor_data(anjay_t *anjay,
    const anjay_dm_object_def_t *const *def, float anomaly, float *data) {
    if (!anjay || !def) {
        return;
    }

    anomaly_analyzer_object_t *obj = get_obj(def);

    SYNCHRONIZED(obj->instance_state_mtx) {
        if (anomaly > obj->anomaly_score) {
            for (size_t i = 0; i < obj->window_size; i++) {
                obj->sensor_data[i] = data[i];
            }
            obj->anomaly_score = anomaly;

            anjay_notify_changed(anjay, obj->def->oid, 0,
                RID_MAXIMUM_ANOMALY_SCORE);
            anjay_notify_changed(anjay, obj->def->oid, 0,
                RID_RAW_DATA);
        }
    }
}
